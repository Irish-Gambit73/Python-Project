Saved code for later: 


- May 20 22
    def attack(self):
        self.attack_count += 1
        self.is_attacking = True
        t_end = time.time() + 3 * 1
        while time.time() < t_end:
                self.attackqueue = CollisionHandler
                attackray = CollisionBox((-5, -3, 0.4), (1, 1, 6))
                attackray_node = CollisionNode("attack-ray")
                attackray_node.setFromCollideMask(BitMask32.bit(0))
                attackray_node.addSolid(attackray)
                attackrayphysical = self.player.attachNewNode(attackray_node)
                self.cTrav.addCollider(attackrayphysical, self.attackqueue)
                attackrayphysical.show()
                attackrayphysical.setPos(2, -2.5, -0.2)if self.attack_count == 2:
                self.is_attacking = False
                self.is_attacking2 = True
                if self.is_attacking2 == True:
                    attackray = CollisionBox((-5, -3, 0.4), (1, 1, 6))
                    attackray_node = CollisionNode("attack-ray")
                    attackray_node.setFromCollideMask(BitMask32.bit(0))
                    attackray_node.addSolid(attackray)
                    attackrayphysical = self.player.attachNewNode(attackray_node)
                    self.cTrav.addCollider(attackrayphysical, self.queue)
                    attackrayphysical.show()
                    attackrayphysical.setPos(2, -5, -0.2)
                    if self.attack_count == 3:
                        self.is_attacking2 = False
                        self.is_attacking3 = True
                        if self.is_attacking3:
                            attackray = CollisionBox((-5, -3, 0.4), (1, 1, 6))
                            attackray_node = CollisionNode("attack-ray")
                            attackray_node.setFromCollideMask(BitMask32.bit(0))
                            attackray_node.addSolid(attackray)
                            attackrayphysical = self.player.attachNewNode(attackray_node)
                            self.cTrav.addCollider(attackrayphysical, self.queue)
                            attackrayphysical.show()
                            attackrayphysical.setPos(2, -9, -0.2)
                            self.is_attacking3 = False
END

- May 27/22
        if self.playerhealth < 0:
            self.alive = False
            return task.cont

        if self.playerhealth2 < 0:
            self.alive2 = False
            return task.cont
END

- May 31/22
    def setAI(self):
        #Creating AI World
        self.AIworld = AIWorld(render)

        self.AIchar = AICharacter("seeker", self.enemy1, 100, 0.05, 5)
        self.AIworld.addAiChar(self.AIchar)
        self.AIbehaviors = self.AIchar.getAiBehaviors()

        self.AIbehaviors.seek(self.player1)
        self.enemy1.loop("run")
END

- June 2 /22
def removeCollectible(nodename, parent, removeColNode=True):
    collisionNode = parent.find("**/%s" % nodename)
    if collisionNode == -1:
        return
    base.cTrav.removeCollider(collisionNode)
    if removeColNode:
        collisionNode.removeNode()


def cleanupCollisionDetection():
    logging.debug("Cleanup Collision detection")
    base.nonphysicsPusher.clearColliders()
    base.cTrav.clearColliders()
    # TODO: Check if this was really necessary as it isn't available within p3d files
    #base.cTrav.clearRecorder()
   
END

- June 6 /22
